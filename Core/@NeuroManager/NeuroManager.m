%{
NeuroManager Simulation Manager for Neuroscience
RELEASE 0.961
September 2015

An application from the Santamaria Laboratory at the 
University of Texas at San Antonio
( http://utsa.edu/Santamarialab/index.htm ).

Grant Acknowledgments:
Funding: NSF-EF 1137897, NSF-DBI 1451032, NIH-G12MD007591 (for use of computational
542 facilities at UTSA), Texas Advanced Computing Center for providing HPC resources.

Software Developer(s): 
David Bruce Stockton
davidbrucestocktonbme@gmail.com

Project PI:
Fidel.Santamaria@utsa.edu

NeuroManager 0.961

UTSA RESEARCH LICENSE (SOURCE CODE)
The University of Texas at San Antonio has developed certain software and
documentation that it desires to make available without charge to anyone for
academic, research, experimental or personal use. This license is designed
to guarantee freedom to use the software for these purposes. If you wish to
distribute or make other use of the software, you may purchase a license to
do so from the University of Texas.
The accompanying source code is made available to you under the terms of
this UT Research License (this "UTRL"). By clicking the "ACCEPT" button,
or by installing or using the code, you are consenting to be bound by
this UTRL. If you do not agree to the terms and conditions of this license,
do not click the "ACCEPT" button, and do not install or use any part
of the code.
The terms and conditions in this UTRL not only apply to the source code
made available by UT, but also to any improvements to, or derivative works
of, that source code made by you and to any object code compiled from such
source code, improvements or derivative works.
1. DEFINITIONS.
1.1 "Commercial Use" shall mean use of Software or Documentation by Licensee
for direct or indirect financial, commercial or strategic gain or advantage,
including without limitation: (a) bundling or integrating the Software with
any hardware product or another software product for transfer, sale or license
to a third party (even if distributing the Software on separate media and not
charging for the Software); (b) providing customers with a link to the
Software or a copy of the Software for use with hardware or another software
product purchased by that customer; or (c) use in connection with the
performance of services for which Licensee is compensated.
1.2 "Derivative Products" means any improvements to, or other derivative
works of, the Software made by Licensee.
1.3 "Documentation" shall mean all manuals, user documentation, and other
related materials pertaining to the Software that are made available to
Licensee in connection with the Software.
1.4 "Licensor" shall mean The University of Texas.
1.5 "Licensee" shall mean the person or entity that has agreed to the
terms hereof and is exercising rights granted hereunder.
1.6 "Software" shall mean the computer program(s) referred to as
"Fractional Integration Toolbox 1.0" made available under this UTRL in
source code form, including any error corrections, bug fixes, patches,
updates or other modifications that Licensor may in its sole discretion
make available to Licensee from time to time, and any object code compiled
from such source code.
2. GRANT OF RIGHTS.
Subject to the terms and conditions hereunder, Licensor hereby grants to
Licensee a worldwide, non- transferable, non-exclusive license to (a) install,
use and reproduce the Software for academic, research,
experimental and personal use (but specifically excluding Commercial Use);
(b) use and modify the Software to create Derivative Products, subject
to Section 3.2; and (c) use the Documentation, if any, solely in connection
with Licensee's authorized use of the Software.
3. RESTRICTIONS; COVENANTS.
3.1 Licensee may not: (a) distribute, sub-license or otherwise transfer copies
or rights to the Software (or any portion thereof) or the Documentation;
(b) use the Software (or any portion thereof) or Documentation for
Commercial Use, or for any other use except as described in Section 2;
(c) copy the Software or Documentation other than for archival and
backup purposes; or (d) remove any product identification, copyright,
proprietary notices or labels from the Software and Documentation.
This UTRL confers no rights upon Licensee except those expressly granted herein.
3.2 Licensee hereby agrees that it will provide a copy of all Derivative
Products to Licensor and that its use of the Derivative Products will be
subject to all of the same terms, conditions, restrictions and limitations
on use imposed on the Software under this UTRL. Licensee hereby grants
Licensor a worldwide, non- exclusive, royalty-free license to reproduce,
prepare derivative works of, publicly display, publicly
perform, sublicense and distribute Derivative Products. Licensee also hereby
grants Licensor a worldwide, non-exclusive, royalty-free patent license to
make, have made, use, offer to sell, sell, import and otherwise transfer the
Derivative Products under those patent claims licensable by Licensee that
are necessarily infringed by the Derivative Products.
4. PROTECTION OF SOFTWARE.
4.1 Confidentiality. The Software and Documentation are the confidential and
proprietary information of Licensor. Licensee agrees to take adequate steps to
protect the Software and Documentation from unauthorized disclosure or use.
Licensee agrees that it will not disclose the Software or Documentation to
any third party.
4.2 Proprietary Notices. Licensee shall maintain and place on any copy of
Software or Documentation that it reproduces for internal use all notices
as are authorized and/or required hereunder. Licensee shall include a copy
of this UTRL and the following notice, on each copy of the Software and
Documentation. Such license and notice shall be embedded in each copy of
the Software, in the video screen display, on the physical medium embodying
the Software copy and on any Documentation:
Copyright Â© 2013, The University of Texas at San Antonio. All rights reserved.
UNIVERSITY EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING THIS SOFTWARE
AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR
ANY PARTICULAR PURPOSE, NON- INFRINGEMENT AND WARRANTIES OF PERFORMANCE, AND
ANY WARRANTY THAT MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT TO THE USE OF
THE SOFTWARE OR DOCUMENTATION. Under no circumstances shall University be
liable for incidental, special, indirect, direct or consequential damages
or loss of profits, interruption of business, or related expenses which
may arise from use of Software or Documentation, including but not limited
to those resulting from defects in Software and/or Documentation, or loss
or inaccuracy of data of any kind.
5. WARRANTIES.
5.1 Disclaimer of Warranties. TO THE EXTENT PERMITTED BY APPLICABLE LAW,
THE SOFTWARE AND DOCUMENTATION ARE BEING PROVIDED ON AN "AS IS" BASIS WITHOUT
ANY WARRANTIES OF ANY KIND RESPECTING THE SOFTWARE OR DOCUMENTATION, EITHER
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF DESIGN,
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
5.2 Limitation of Liability. UNDER NO CIRCUMSTANCES UNLESS REQUIRED BY
APPLICABLE LAW SHALL LICENSOR BE LIABLE FOR INCIDENTAL, SPECIAL, INDIRECT,
DIRECT OR CONSEQUENTIAL DAMAGES OR LOSS OF PROFITS, INTERRUPTION OF BUSINESS,
OR RELATED EXPENSES WHICH MAY ARISE AS A RESULT OF THIS LICENSE OR OUT OF
THE USE OR ATTEMPT OF USE OF SOFTWARE OR DOCUMENTATION INCLUDING BUT NOT
LIMITED TO THOSE RESULTING FROM DEFECTS IN SOFTWARE AND/OR DOCUMENTATION,
OR LOSS OR INACCURACY OF DATA OF ANY KIND. THE FOREGOING EXCLUSIONS AND
LIMITATIONS WILL APPLY TO ALL CLAIMS AND ACTIONS OF ANY KIND, WHETHER
BASED ON CONTRACT, TORT (INCLUDING, WITHOUT LIMITATION, NEGLIGENCE), OR
ANY OTHER GROUNDS.
6. INDEMNIFICATION.
Licensee shall indemnify, defend and hold harmless Licensor, the
University of Texas System, their Regents, and their officers,
agents and employees from and against any claims, demands, or
causes of action whatsoever caused by, or arising out of, or resulting
from, the exercise or practice of the license granted hereunder by
Licensee, its officers, employees, agents or representatives.
7. TERMINATION.
If Licensee breaches this UTRL, Licensee's right to use the Software
and Documentation will terminate immediately without notice, but all
provisions of this UTRL except Section 2 will survive termination and
continue in effect. Upon termination, Licensee must destroy all copies
of the Software and Documentation.
8. GOVERNING LAW; JURISDICTION AND VENUE.
The validity, interpretation, construction and performance of this UTRL
shall be governed by the laws of the State of Texas. The Texas state
courts of Travis County, Texas (or, if there is exclusive federal
jurisdiction,the United States District Court for the Central
District of Texas) shall have exclusive jurisdiction and venue
over any dispute arising out of this UTRL, and Licensee consents
to the jurisdiction of such courts. Application of the
United Nations Convention on Contracts for the International
Sale of Goods is expressly excluded.
9. EXPORT CONTROLS.
This license is subject to all applicable export restrictions. Licensee
must comply with all export and import laws and restrictions and
regulations of any United States or foreign agency or authority relating
to the Software and its use.
10. U.S. GOVERNMENT END-USERS.
The Software is a "commercial item," as that term is defined in
48 C.F.R. 2.101, consisting of "commercial computer software" and
"commercial computer software documentation," as such terms are
used in 48 C.F.R. 12.212 (Sept. 1995) and 48 C.F.R. 227.7202 (June 1995).
Consistent with 48 C.F.R. 12.212, 48 C.F.R. 27.405(b)(2) (June 1998)
and 48 C.F.R. 227.7202, all U.S. Government End Users acquire the
Software with only those rights as set forth herein.
11. MISCELLANEOUS
If any provision hereof shall be held illegal, invalid or unenforceable,
in whole or in part, such provision shall be modified to the minimum extent
necessary to make it legal, valid and enforceable, and the legality, validity
and enforceability of all other provisions of this UTRL shall not be affected
thereby. Licensee may not assign this UTRL in whole or in part, without
Licensor's prior written consent. Any attempt to assign this UTRL without
such consent will be null and void. This UTRL is the complete and exclusive
statement between Licensee and Licensor relating to the subject matter
hereof and supersedes all prior oral and written and all contemporaneous
oral negotiations, commitments and understandings of the parties, if any.
Any waiver by either party of any default or breach hereunder shall
not constitute a waiver of any provision of this UTRL or of any
subsequent default or breach of the same or a different kind.
END OF LICENSE
%}

% NeuroManager.m
% NeuroManager takes a SimSetSpec as input, turns it into a SimSet, expresses
% the SimSet on a Simulator Pool, and places the results in a separate
% directory for each SimSet, labeled with the SimSet ID.  
classdef NeuroManager < handle
    properties
        nmMainDir;         % The installation path of NeuroManager
        simCoreDir;        % Where the NeuroManager and standard simulator files are located
                           % (the NeuroManager host installation; not the
                           % SimCore on the remote)
        sshLibDir;         % Where the SSH library files are located
        customSimDir;      % Where user custom files are located
        modelFileDir;      % Where model files are located
        localMachineDir;   % Where local machine files are located
        simSpecFileDir;    % Where to look for the SimSpec
        simResultsBaseDir; % Where user wants the results tree to be attached
        simResultsDir;     % The pathname of the results tree (automatically generated)
        curlDir;           % The path of the directory containing the cURL executable

        oldPath;    % Retains user's old MATLAB search path for the duration
        
        singleMachine; % t/f
        
        auth; % The SimAuthentication object for this instantiation
        authFile; % The full host path of the Open SSH-format private key
        puttyAuthFile; % The full host path of the Putty-format private key
        useDualKey;
        
        % Data on the function invoking NeuroManager
        callingFunctionData;
        
        % The full pathname of the SimSpec file
        simSpecFullPath;
        
        % The SimSet to be processed
        nmSimSet;
        
        % The configuration to use for creating the ML Compile machine
        mLCompileConfig;
        % MATLAB Compiled Files Transfer List - the list of files that need
        % to be distributed to the machines after single-point compilation
        MLCFTL; 
        files2Compile;      % Not sure if need this
        files2Upload;       % Not sure if need this
        modelFiles2Upload;  % Not sure if need this 
        compiledType = SimType.UNASSIGNED;  % Simulator type set by user
        MLCompilerVersion = ''; % determined automatically during compilation
        
        % The configuration of the machine set to set up
        machineSetConfig;
        
        % The data of the machine running NeuroManager
        hostMachineData; 
        
        % The current set of SimMachines
        machineSet;
        % The simtype of the current machineSet
        machineSetType;
        % The total number of machines in the current machineSet
        numMachines;
        % The host working location for machines to make files, etc
        machineScratchDir;
        ML2CompileDir;  % Holds remote-destined-m-files for MATLAB compilation
        MLCompiledDir;  % Holds MATLAB compilation products before upload
        toUploadDir;    % Holds remote-destined-non-m-files before upload
        toModelRepoDir; % Holds remote-destined model files before upload
        
        % The set of Simulators NeuroManager has available for running sims
        simulatorPool;
        % The number of simulators in the pool
        numSimulators;
        
        % A timedelay for polling that reduces load on the host during
        % remote simulation. In seconds; 0 < x <= 300 (change this in the
        % input parser).
        pollDelay;
        
        % The approx time of the end of the last simulation status update
        snapshotTimeStr = '--------------------';
        
        % The log for the entire session and all classes
        log;
        logEchoFlag; % if true echoes log to command window.
        
        % If true will create and update the in-MATLAB status webpage;  if
        % false will still create the page but not display it in MATLAB
        showWebPage = true;
        
        % Notifications to the user are handled through this object
        simNotificationSet;
        
        % NeuroManager Version; synced with GIT repository
        version;
    end
    
    methods (Access = public)
        % ---
        function obj = NeuroManager(varargin)
        % NeuroManager constructor
            obj.version = '0.981';
            
            obj.callingFunctionData = dbstack('-completenames');

            obj.hostMachineData.id = obj.getHostComputerName();
            comp = computer;
            % Currently no support for Mac host
            if (strcmp(comp, 'PCWIN') || strcmp(comp, 'PCWIN64'))
                obj.hostMachineData.osType = OSType.WINDOWS;
            else
                obj.hostMachineData.osType = OSType.UNIX;
            end

            p = obj.neuroManagerInputParser();
            parse(p, varargin{:});

            % Set the dirs; the parser made sure they exist on the host
            obj.nmMainDir = pathConversion(p.Results.nmMainDir,...
                                           obj.hostMachineData.osType);
            obj.simCoreDir = pathConversion(p.Results.coreDir,...
                                            obj.hostMachineData.osType);
            obj.sshLibDir = pathConversion(p.Results.sshLibDir,...
                                           obj.hostMachineData.osType);
            obj.customSimDir = pathConversion(p.Results.customDir,...
                                              obj.hostMachineData.osType);
            obj.modelFileDir = pathConversion(p.Results.modelDir,...
                                              obj.hostMachineData.osType);
            obj.simResultsBaseDir = pathConversion(p.Results.resultsDir,...
                                                   obj.hostMachineData.osType);
            obj.localMachineDir = pathConversion(p.Results.localMachineDir,...
                                                 obj.hostMachineData.osType);
            obj.simSpecFileDir = pathConversion(p.Results.simSpecFileDir,...
                                                 obj.hostMachineData.osType);
            obj.curlDir = pathConversion(p.Results.curlDir,...
                                                 obj.hostMachineData.osType);
            % Add the custom directory to the
            % MATLAB search path; that is where the user's
            % UserSimulation function must be located as well as other
            % simulation files. 
            % Add it to the MATLAB search path and preserve old
            obj.oldPath = addpath(obj.customSimDir);

            obj.simSpecFullPath = '';  % Set in RunFromFile()
            obj.nmSimSet = SimSet();   % actually assigned in nmRun()
            
            % Construct the SimDateTime directory for the SimSets to
            % use for results
            formatOut = 'yyyy-mm-dd_HHMMSS';
            obj.simResultsDir = fullfile(obj.simResultsBaseDir, ...
                                     ['SimResults_' datestr(now, formatOut)]);
            [status, ~, ~] = mkdir(obj.simResultsDir);
            if ~status
                ME = MException('ClassdefNeuroManager:simResultsDirMakeFailure', ...
                                ['NeuroManager: Could not create simResultsDir Directory '...
                                 obj.simResultsDir '.']);
                throw(ME);
            end

            % Create the notifications mechanism
            obj.simNotificationSet = NotificationSet();

            % Now set notifications according to input parameters
            switch p.Results.notificationsType
                case {'TEXT', 'EMAIL', 'BOTH'}
                    messageDelay = 2.0; % Hardwired message delay is temporary
                    obj.simNotificationSet.setup(p.Results.notificationsType, ...
                                    p.Results.phone, p.Results.carrier,...
                                    p.Results.email, p.Results.smtpServer,...
                                    messageDelay);
                    pause on % for separating notifications
                case {'OFF', 'NONE'}
                    obj.simNotificationSet.turnOff();
                otherwise
                    ME = MException('ClassdefNeuroManager:ConstructorInvalidnotificationstype', ...
                            'NeuroManager: Error in NeuroManager constructor: invalid notificationstype.');
                    throw(ME);
            end

            % Create the log (must be done before the SimSets and
            % before any Notification is sent)
            obj.logEchoFlag = p.Results.logEchoFlag;
            obj.log = SimLog(fullfile(obj.simResultsDir,...
                                      'SimLogFile.log'), obj.logEchoFlag);
            if obj.logEchoFlag
                obj.log.write(['Log Echo to Command Window is ON.']);
            else
                obj.log.write(['Log Echo to Command Window is OFF.']);
            end
            obj.log.write(['***** NeuroManager '...
                           obj.version ' started on host computer '''...
                           obj.hostMachineData.id ''' *****']);

            obj.log.write(['SimMain Directory: ' obj.simCoreDir]);
            obj.log.write(['CustomSim Directory: ' obj.customSimDir]);
            obj.log.write(['ModelFile Directory: ' obj.modelFileDir]);
            obj.log.write(['LocalMachine Directory: ' obj.localMachineDir]);
            obj.log.write(['SimResultsBase Directory: ' obj.simResultsBaseDir]);
            obj.log.write(['SimResults Directory: ' obj.simResultsDir]);
            obj.log.write(['cURL Directory: ' obj.curlDir]);

            % Tell Notifications about the new log
            obj.simNotificationSet.setLog(obj.log);
            if obj.simNotificationSet.inUse()
                if(obj.simNotificationSet.isEnabled())
                    notificationState = 'ON';
                else
                    notificationState = 'OFF';
                end
                obj.log.write(['Notifications of type '...
                               obj.simNotificationSet.getType() ...
                               ' are ready and turned '...
                               notificationState '.']);
            else
                obj.log.write('Notifications are not in use.');
            end

            % Web page display controls
            obj.showWebPage = p.Results.showWebPage;
            
            % Make the machine scratch directory and subdirectories
            obj.machineScratchDir = fullfile(obj.simResultsDir, 'MachineScratch');
            [status, ~, ~] =  mkdir(obj.machineScratchDir);
            if ~status
                ME = MException('ClassdefNeuroManager:machineScratchDirMakeFailure', ...
                                ['NeuroManager: Could not create Machine Scratch Directory '...
                                 obj.machineScratchDir '.']);
                throw(ME);
            end
            obj.ML2CompileDir = fullfile(obj.machineScratchDir, 'ML2Compile');
            [status1, ~, ~] = mkdir(obj.ML2CompileDir);               
            obj.toUploadDir = fullfile(obj.machineScratchDir, 'ToUpload');
            [status2, ~, ~] = mkdir(obj.toUploadDir);                 
            obj.toModelRepoDir = fullfile(obj.machineScratchDir, 'ToModelRepo');
            [status3, ~, ~] = mkdir(obj.toModelRepoDir);                 
            obj.MLCompiledDir = fullfile(obj.machineScratchDir, 'MLCompiled');
            [status4, ~, ~] = mkdir(obj.MLCompiledDir);               
            if ~(status1 && status2 && status3 && status4)
                ME = MException('ClassdefNeuroManager:machineScratchDirMakeFailure', ...
                                ['NeuroManager: Could not create Machine Scratch SubDirectory.']);
                throw(ME);
            end
            
            % Single Machine configuration (= true) eliminates all
            % authentication and authentication setup, regardless of other
            % authentication settings. Default = false.
            obj.singleMachine = p.Results.isSingleMachine;
            if obj.singleMachine
                if obj.hostMachineData.osType ~= OSType.UNIX
                    error('NeuroManagerConstructor Error: isSingleMachine option requires UNIX host.');
                end
            end

            % Set up SSH authentication services 
            obj.useDualKey = p.Results.useDualKey;
            obj.authFile = pathConversion(p.Results.authFile, obj.hostMachineData.osType);
            obj.puttyAuthFile = pathConversion(p.Results.puttyAuthFile, obj.hostMachineData.osType);
            obj.auth = SimAuthenticate(obj.singleMachine,...
                                       obj.useDualKey,...
                                       obj.authFile,...
                                       obj.puttyAuthFile,...
                                       obj.hostMachineData.osType,...
                                       obj.machineScratchDir,...
                                       obj.log);

            % pollDelay determines how often Simulators will be checked
            % for state changes
            obj.pollDelay = p.Results.pollDelay;
            obj.log.write(['pollDelay set at ' num2str(obj.pollDelay)]);

            % Connect to the Java Ganymed library if necessary.
            if ~obj.singleMachine
                % First ensure that we are using the NeuroManager
                % override version of ssh2_setup, and that the java library
                % exists in the Core directory.
                ssh2JavaLibJar = 'ganymed-ssh2-m1.jar';
                ssh2JavaLibJarPath = fullfile(obj.sshLibDir, ssh2JavaLibJar);
                query = ssh2_setup('?');
                if ~(ischar(query) && strcmp(query, '!'))
                    error(['Installation error: the NeuroManager override '...
                           'version of the ssh2_setup.m file must exist '...
                           'in the SSHLib directory. '...
                           'See the User Guide for proper installation '...
                           'procedure.']);
                end
                if ~(exist(ssh2JavaLibJarPath, 'file') == 2)
                    error(['Installation error: the Java Ganymed library '...
                           ssh2JavaLibJar ...
                           ' must be present in the SSHLib directory. '...
                           'See the User Guide for proper installation '...
                           'procedure.']);
                end
                javaaddpath(ssh2JavaLibJarPath);
                %javaclasspath(ssh2javalibjar);
            end

            % Initialize the Machine Set type
            obj.machineSetType = SimType.UNASSIGNED;
            
            % Initialize the machineSetConfiguration; the user configures
            % this overtly in the script
            obj.machineSetConfig = ...
                MachineSetConfig(obj.isSingleMachine(), obj.curlDir, ...
                                 obj.auth, obj.log);

            % Send a "starting" message to verify notifications setup
            if obj.simNotificationSet.isEnabled()
                notificationSubject = ['NeuroManager Notice'];
                obj.simNotificationSet.send(notificationSubject,...
                 ['Notifications Ready.'], '');
            end
            % Start up the webpage, mostly to clear out the previous run
            obj.displayStatusWebPage('initial');
        end
        
        % ---
        function result = runFromSimSpec(obj, simspec)
        % Runs the input simspec on the set of simulators built in the
        % NeuroManager constructor.
            obj.log.write('NeuroManager: beginning run.');
           
            % Populate the simulator pool from the current machine set
            obj.simulatorPool = {};
            for i = 1: obj.numMachines
                obj.simulatorPool = [obj.simulatorPool,...
                            obj.machineSet{i}.getSimulators()];
            end
            [~, obj.numSimulators] = size(obj.simulatorPool);
            
            % PREPARATION
            % Make the SimSet from the simspec
            obj.log.write(['Constructing SimSet from supplied simspec.']);
            simset = SimSet('', simspec, obj.simResultsDir,...
                                  obj.log, obj.simNotificationSet);
            obj.log.write('SimSet constructed.'); % NEED ERROR MSG IF FAILS

            result = obj.nmRun(simset);
        end
        
        % ---
        function result = runFromFile(obj, simspecFilename)
        % Runs the simspec on the set of simulators built in the
        % NeuroManager constructor.
            obj.log.write('NeuroManager: beginning run.');
           
            % Populate the simulator pool from the current machine set
            obj.simulatorPool = {};
            for i = 1: obj.numMachines
                obj.simulatorPool = [obj.simulatorPool,...
                            obj.machineSet{i}.getSimulators()];
            end
            [~, obj.numSimulators] = size(obj.simulatorPool);
            
            % PREPARATION
            % Make the SimSet. SimSpec file must be in simspec dir
            obj.simSpecFullPath = fullfile(obj.simSpecFileDir,...
                                           simspecFilename);
            obj.log.write(['Constructing SimSet from file '...
                           obj.simSpecFullPath    '.']);
            simset = SimSet(obj.simSpecFullPath, 0, obj.simResultsDir,...
                                  obj.log, obj.simNotificationSet);
            obj.log.write('SimSet constructed.'); % NEED ERROR MSG IF FAILS

            result = obj.nmRun(simset);
        end

        % ---
        function removeMachineSet(obj)
        % Remove all the machines in the machine set
            if obj.machineSetType ~= SimType.UNASSIGNED
                % Not the ideal place for this but ok for now
                obj.setSnapshotTimeStr(datestr(now));
                obj.displayStatusWebPage('final');
                obj.log.write(['Removing machine set.']);
                for i = 1:obj.numMachines
                    obj.machineSet{i}.delete();
                end
                obj.machineSetType = SimType.UNASSIGNED;
                obj.log.write(['Machine set removed.']);
            end
        end
        
        % ---
        function shutdown(obj)
        % Remove the remote machines and close up shop
        % This may turn into a destructor but not yet
            obj.removeMachineSet();
            
            obj.auth.delete();
        
            if obj.simNotificationSet.isEnabled()
                notificationSubject = ['Re: NeuroManager Notice'];
                obj.simNotificationSet.send(notificationSubject,...
                                            'Simulation activity complete.', '');
            end

            obj.log.write(['Simulation activities complete.  All results placed under '...
                    obj.simResultsDir]);
                
            % Place a link to the results directory in the command window
            % in case the webpage is disabled
            if obj.hostMachineData.osType == OSType.WINDOWS
                disp(['Click here to <a href="matlab:winopen(''' ...
                      obj.getSimResultsDir() ...
                      '''); ">open the results directory.</a>']);
            else
                disp(['Click here to <a href="matlab:cd '...
                      obj.localMachineDir ...
                      ';openMyUNIXDirectory(''' ...
                      path2UNIX(obj.getSimResultsDir()) ...
                      ''');">open the results directory</a>']);
            end
                
            % Restore the old MATLAB search path
            path(obj.oldPath);
        end
        
        % ---
        function tf = isSingleMachine(obj)
            tf = obj.singleMachine;
        end

        % ---
        function version = getVersion(obj)
            version = obj.version;
        end
        
        % ---
        function setSnapshotTimeStr(obj, str)
            obj.snapshotTimeStr = str;
        end
        
        % ---
        function str = getSnapshotTimeStr(obj)
            str = obj.snapshotTimeStr;
        end
        
        % ---
        function dir = getSimResultsDir(obj)
            dir = obj.simResultsDir;
        end 
        
        % ---
        function setSimSpecFileDir(obj, dir)
                newDir = pathConversion(dir, obj.hostMachineData.osType);
            if ~exist(newDir, 'dir')
                error(['Could not set simSpecFileDir to ' newDir ...
                       ' - directory does not exist.']);
            end
            obj.simSpecFileDir = newDir;
        end
        
        % ---
        function dir = getSimSpecFileDir(obj)
            dir = obj.simSpecFileDir;
        end
        
        % ---
        function log = getLog(obj)
            log = obj.log;
        end
        
        % Interface for the config class
        % --- 
        function addStandaloneServer(obj, varargin)
            if obj.machineSetType ~= SimType.UNASSIGNED
                obj.machineSetConfig.addStandaloneServer(obj.machineSetType, varargin{:});
            else
                error(['User must assign Simulator Type using the NeuroManager class method setSimulatorType() before using this method.']);
            end
        end
        
        % ---
        function addClusterQueue(obj, varargin)
            if obj.machineSetType ~= SimType.UNASSIGNED
                obj.machineSetConfig.addClusterQueue(obj.machineSetType, varargin{:});
            else
                error(['User must assign Simulator Type using the NeuroManager class method setSimulatorType() before using this method.']);
            end
        end
        
        % ---
        function addCloudServer(obj, varargin)
            if obj.machineSetType ~= SimType.UNASSIGNED
                obj.machineSetConfig.addCloudServer(obj.machineSetType, varargin{:});
            else
                error(['User must assign Simulator Type using the NeuroManager class method setSimulatorType() before using this method.']);
            end
        end            
        
        % ---
        function addWisp(obj, varargin)
            if obj.machineSetType ~= SimType.UNASSIGNED
                obj.machineSetConfig.addWisp(obj.machineSetType, varargin{:});
            else
                error(['User must assign Simulator Type using the NeuroManager class method setSimulatorType() before using this method.']);
            end
        end
        
        % ---
        function addWispSet(obj, varargin)
            if obj.machineSetType ~= SimType.UNASSIGNED
                obj.machineSetConfig.addWispSet(obj.machineSetType, varargin{:});
            else
                error(['User must assign Simulator Type using the NeuroManager class method setSimulatorType() before using this method.']);
            end
        end
        
        % ---
        function removeWisps(obj)
            obj.machineSetConfig.removeWisps();
        end
        
        % ---
        function terminateCloudInstance(obj, resourceName, instanceName)
            obj.machineSetConfig.terminateCloudInstance(resourceName, instanceName);
        end
        
        % ---
        function printConfig(obj)
            obj.machineSetConfig.print();
        end
        
        % ---
        function setSimulatorType(obj, type)
            % if type valid
            try
                obj.machineSetType = type;
            catch
                error(['setSimulatorType error: ' type ' is not a valid SimType.']);
            end
        end
    end 
    
    methods (Access = private)
        result = nmRun(obj, simset) % function defn in separate file
        preUploadFiles(obj, machine) % function defn in separate file
        
        % ---
        function addSimulatorToPool(obj, simulator)
        % Puts the input simulator into the simulator pool
        % Assumes the simulator is valid
            obj.numSimulators = obj.numSimulators +1;
            obj.simulatorPool{obj.numSimulators} = simulator;
        end
        
        % ---
        function result = machineSetReady(obj)
            % Boolean; true if all machines in the set are ready to go
            result = true;
            % We need to touch every machine, because this is what prompts
            % the check for compilation done, and the compilations may not
            % finish in construction order.
            for i = 1:obj.numMachines
                if ~obj.machineSet{i}.isReady()
                    result = false;
                end
            end
        end
    end
end
