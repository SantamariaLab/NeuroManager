%{
NeuroManager Simulation Manager for Neuroscience
RELEASE 0.961
September 2015

An application from the Santamaria Laboratory at the 
University of Texas at San Antonio
( http://utsa.edu/Santamarialab/index.htm ).

Grant Acknowledgments:
Funding: NSF-EF 1137897, NSF-DBI 1451032, NIH-G12MD007591 (for use of computational
542 facilities at UTSA), Texas Advanced Computing Center for providing HPC resources.

Software Developer(s): 
David Bruce Stockton
davidbrucestocktonbme@gmail.com

Project PI:
Fidel.Santamaria@utsa.edu

NeuroManager 0.961

UTSA RESEARCH LICENSE (SOURCE CODE)
The University of Texas at San Antonio has developed certain software and
documentation that it desires to make available without charge to anyone for
academic, research, experimental or personal use. This license is designed
to guarantee freedom to use the software for these purposes. If you wish to
distribute or make other use of the software, you may purchase a license to
do so from the University of Texas.
The accompanying source code is made available to you under the terms of
this UT Research License (this "UTRL"). By clicking the "ACCEPT" button,
or by installing or using the code, you are consenting to be bound by
this UTRL. If you do not agree to the terms and conditions of this license,
do not click the "ACCEPT" button, and do not install or use any part
of the code.
The terms and conditions in this UTRL not only apply to the source code
made available by UT, but also to any improvements to, or derivative works
of, that source code made by you and to any object code compiled from such
source code, improvements or derivative works.
1. DEFINITIONS.
1.1 "Commercial Use" shall mean use of Software or Documentation by Licensee
for direct or indirect financial, commercial or strategic gain or advantage,
including without limitation: (a) bundling or integrating the Software with
any hardware product or another software product for transfer, sale or license
to a third party (even if distributing the Software on separate media and not
charging for the Software); (b) providing customers with a link to the
Software or a copy of the Software for use with hardware or another software
product purchased by that customer; or (c) use in connection with the
performance of services for which Licensee is compensated.
1.2 "Derivative Products" means any improvements to, or other derivative
works of, the Software made by Licensee.
1.3 "Documentation" shall mean all manuals, user documentation, and other
related materials pertaining to the Software that are made available to
Licensee in connection with the Software.
1.4 "Licensor" shall mean The University of Texas.
1.5 "Licensee" shall mean the person or entity that has agreed to the
terms hereof and is exercising rights granted hereunder.
1.6 "Software" shall mean the computer program(s) referred to as
"Fractional Integration Toolbox 1.0" made available under this UTRL in
source code form, including any error corrections, bug fixes, patches,
updates or other modifications that Licensor may in its sole discretion
make available to Licensee from time to time, and any object code compiled
from such source code.
2. GRANT OF RIGHTS.
Subject to the terms and conditions hereunder, Licensor hereby grants to
Licensee a worldwide, non- transferable, non-exclusive license to (a) install,
use and reproduce the Software for academic, research,
experimental and personal use (but specifically excluding Commercial Use);
(b) use and modify the Software to create Derivative Products, subject
to Section 3.2; and (c) use the Documentation, if any, solely in connection
with Licensee's authorized use of the Software.
3. RESTRICTIONS; COVENANTS.
3.1 Licensee may not: (a) distribute, sub-license or otherwise transfer copies
or rights to the Software (or any portion thereof) or the Documentation;
(b) use the Software (or any portion thereof) or Documentation for
Commercial Use, or for any other use except as described in Section 2;
(c) copy the Software or Documentation other than for archival and
backup purposes; or (d) remove any product identification, copyright,
proprietary notices or labels from the Software and Documentation.
This UTRL confers no rights upon Licensee except those expressly granted herein.
3.2 Licensee hereby agrees that it will provide a copy of all Derivative
Products to Licensor and that its use of the Derivative Products will be
subject to all of the same terms, conditions, restrictions and limitations
on use imposed on the Software under this UTRL. Licensee hereby grants
Licensor a worldwide, non- exclusive, royalty-free license to reproduce,
prepare derivative works of, publicly display, publicly
perform, sublicense and distribute Derivative Products. Licensee also hereby
grants Licensor a worldwide, non-exclusive, royalty-free patent license to
make, have made, use, offer to sell, sell, import and otherwise transfer the
Derivative Products under those patent claims licensable by Licensee that
are necessarily infringed by the Derivative Products.
4. PROTECTION OF SOFTWARE.
4.1 Confidentiality. The Software and Documentation are the confidential and
proprietary information of Licensor. Licensee agrees to take adequate steps to
protect the Software and Documentation from unauthorized disclosure or use.
Licensee agrees that it will not disclose the Software or Documentation to
any third party.
4.2 Proprietary Notices. Licensee shall maintain and place on any copy of
Software or Documentation that it reproduces for internal use all notices
as are authorized and/or required hereunder. Licensee shall include a copy
of this UTRL and the following notice, on each copy of the Software and
Documentation. Such license and notice shall be embedded in each copy of
the Software, in the video screen display, on the physical medium embodying
the Software copy and on any Documentation:
Copyright Â© 2013, The University of Texas at San Antonio. All rights reserved.
UNIVERSITY EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING THIS SOFTWARE
AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR
ANY PARTICULAR PURPOSE, NON- INFRINGEMENT AND WARRANTIES OF PERFORMANCE, AND
ANY WARRANTY THAT MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT TO THE USE OF
THE SOFTWARE OR DOCUMENTATION. Under no circumstances shall University be
liable for incidental, special, indirect, direct or consequential damages
or loss of profits, interruption of business, or related expenses which
may arise from use of Software or Documentation, including but not limited
to those resulting from defects in Software and/or Documentation, or loss
or inaccuracy of data of any kind.
5. WARRANTIES.
5.1 Disclaimer of Warranties. TO THE EXTENT PERMITTED BY APPLICABLE LAW,
THE SOFTWARE AND DOCUMENTATION ARE BEING PROVIDED ON AN "AS IS" BASIS WITHOUT
ANY WARRANTIES OF ANY KIND RESPECTING THE SOFTWARE OR DOCUMENTATION, EITHER
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF DESIGN,
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
5.2 Limitation of Liability. UNDER NO CIRCUMSTANCES UNLESS REQUIRED BY
APPLICABLE LAW SHALL LICENSOR BE LIABLE FOR INCIDENTAL, SPECIAL, INDIRECT,
DIRECT OR CONSEQUENTIAL DAMAGES OR LOSS OF PROFITS, INTERRUPTION OF BUSINESS,
OR RELATED EXPENSES WHICH MAY ARISE AS A RESULT OF THIS LICENSE OR OUT OF
THE USE OR ATTEMPT OF USE OF SOFTWARE OR DOCUMENTATION INCLUDING BUT NOT
LIMITED TO THOSE RESULTING FROM DEFECTS IN SOFTWARE AND/OR DOCUMENTATION,
OR LOSS OR INACCURACY OF DATA OF ANY KIND. THE FOREGOING EXCLUSIONS AND
LIMITATIONS WILL APPLY TO ALL CLAIMS AND ACTIONS OF ANY KIND, WHETHER
BASED ON CONTRACT, TORT (INCLUDING, WITHOUT LIMITATION, NEGLIGENCE), OR
ANY OTHER GROUNDS.
6. INDEMNIFICATION.
Licensee shall indemnify, defend and hold harmless Licensor, the
University of Texas System, their Regents, and their officers,
agents and employees from and against any claims, demands, or
causes of action whatsoever caused by, or arising out of, or resulting
from, the exercise or practice of the license granted hereunder by
Licensee, its officers, employees, agents or representatives.
7. TERMINATION.
If Licensee breaches this UTRL, Licensee's right to use the Software
and Documentation will terminate immediately without notice, but all
provisions of this UTRL except Section 2 will survive termination and
continue in effect. Upon termination, Licensee must destroy all copies
of the Software and Documentation.
8. GOVERNING LAW; JURISDICTION AND VENUE.
The validity, interpretation, construction and performance of this UTRL
shall be governed by the laws of the State of Texas. The Texas state
courts of Travis County, Texas (or, if there is exclusive federal
jurisdiction,the United States District Court for the Central
District of Texas) shall have exclusive jurisdiction and venue
over any dispute arising out of this UTRL, and Licensee consents
to the jurisdiction of such courts. Application of the
United Nations Convention on Contracts for the International
Sale of Goods is expressly excluded.
9. EXPORT CONTROLS.
This license is subject to all applicable export restrictions. Licensee
must comply with all export and import laws and restrictions and
regulations of any United States or foreign agency or authority relating
to the Software and its use.
10. U.S. GOVERNMENT END-USERS.
The Software is a "commercial item," as that term is defined in
48 C.F.R. 2.101, consisting of "commercial computer software" and
"commercial computer software documentation," as such terms are
used in 48 C.F.R. 12.212 (Sept. 1995) and 48 C.F.R. 227.7202 (June 1995).
Consistent with 48 C.F.R. 12.212, 48 C.F.R. 27.405(b)(2) (June 1998)
and 48 C.F.R. 227.7202, all U.S. Government End Users acquire the
Software with only those rights as set forth herein.
11. MISCELLANEOUS
If any provision hereof shall be held illegal, invalid or unenforceable,
in whole or in part, such provision shall be modified to the minimum extent
necessary to make it legal, valid and enforceable, and the legality, validity
and enforceability of all other provisions of this UTRL shall not be affected
thereby. Licensee may not assign this UTRL in whole or in part, without
Licensor's prior written consent. Any attempt to assign this UTRL without
such consent will be null and void. This UTRL is the complete and exclusive
statement between Licensee and Licensor relating to the subject matter
hereof and supersedes all prior oral and written and all contemporaneous
oral negotiations, commitments and understandings of the parties, if any.
Any waiver by either party of any default or breach hereunder shall
not constitute a waiver of any provision of this UTRL or of any
subsequent default or breach of the same or a different kind.
END OF LICENSE
%}

% Simulator
% The abstract base class for all Simulator classes in the NeuroManager
% software suite.
classdef Simulator < handle
    properties (Access=private)
          extendedSimulatorFileList;
          addlCustomFileList;
    end
    properties
        % Each Simulator has its own ID which will be used in directory
        % names, notifications, logs, and the like.
        id;
        type; % From SimType class
       
        % The lists of files to be uploaded as part of the simulator;
        % dependent on simtype and machine. A cell array of strings.
        % Filenames only
        % NeuroManager Files standard for all simulators plus std simulator-specific
%         stdUploadFiles; 
        baseSimulatorFileList;

%         extendedSimulatorFileList;
        
        % User-supplied UserSimulation.m
        reqdCustomFileList;
%         custUploadFiles; 
        
        % Additional User-supplied simulator files
%         addlCustUploadFiles; 
%         addlCustomFileList;
        
        % Full path of simulator's basedir on target machine
        targetBaseDir;
        % Full path of simulationcommon directory on target machine
        simulationCommonDir;
        
        state; % Defined in class SimulatorState
        
        % The handle of the simulation that is currently being worked on by
        % the simulator. If none, then 0.
        currentSimulation;
        
        % Flag that tells whether simulator has processed the
        % simulation's transition to RUNNING
        processedSimulationRUNNINGTransition = false;
        
        % A command string to be prepended to the job submission string for
        % doing things as part of the simulation submission before the
        % simulation itself is run.
        preRunModelProcDStr;
        
        % Statistics object
        % The timings obtained by Simulations that have run previously;
        % used by the Scheduler (2.0). See SimStats.m.
        stats;

        % The SimMachine on which the simulator is running
        machine;

        % Log handle for this simulator to make log entries 
        log;
        
        % Notification set for this simulator to use for notifying user
        notificationSet;
    end
    properties (Abstract)
        % Every terminal class has to set its version
        version;
    end
    
    methods (Abstract)
        % Refer to NeuroManager Staging Sequence.xlsx
        preUploadFiles(obj)   % The simulator aspect of PreUploadFiles
        preRunModelProcPhaseH(obj)
        preRunModelProcPhaseP(obj)
        preRunModelProcPhaseD(obj)
    end
   
    methods
        % Machine makes the simulator so the caller's handle goes in machine.
        function obj = Simulator(id, machine, log, notificationSet)
            obj.id = id;
            obj.type = SimType.UNASSIGNED; 
            
            % List defined in SimType.m
%     	    obj.simCoreCompatibilityList = type.simCoreList;
            
            % This file list is true for all simulators; located in the
            % core directory
            obj.baseSimulatorFileList = {'runSimulation.m',...
                                         'SimulationState.m',...
                                         'StandaloneConfig.m',...
                                         'ClusterConfig.m',...
                                         'CloudConfig.m',...
                                         'MachineConfig.m',...
                                         'OSType.m'};
            % Simulators can add additional std files that are located
            % in std directory with the rest of the NeuroManager core files
            % PUT THIS LIST INTO THE SIMTYPE; EVEN BETTER POSSIBLY DEFINE A SIMTYPE WITH
            % JSON AND PUT THIS LIST (THE ADDITIONAL STD FILES) INTO THE JSON 
            % DEFINITION OF THE SIMULATOR. The JSON file would only define 
            % the simulator from the machine's point of view and thus enable
            % all-simulator file uploads; the simulator classes would define 
            % simulator-specific file uploads, and the simspec
            % entries/methods would define simulation-specific file
            % uploads. Rename standard/custom/addlstd   
            % to allSRFiles/sRSpecificFiles/sNSpecificFiles.
            % allSRFiles m-files and sRSpecificFiles m-files will be
            % compiled and uploaded by the machine.  allSRFiles and
            % sRSpecificFiles non-m-files will be uploaded by the
            % machine.  sNSpecificFiles files will be uploaded by the
            % simulator for a specific simulation.
            %obj.stdUploadFiles = [obj.stdUploadFiles, addlStdFileList];
            obj.extendedSimulatorFileList = {};
            
            % This file list is true for all simulators; located in the
            % custom directory
            obj.reqdCustomFileList = {'userSimulation.m'};
            
            % Simulators can have additional custom upload files here;
            % located in the custom directory
            obj.addlCustomFileList = {};
            
            obj.state = SimulatorState.INPREPARATION;
            obj.currentSimulation = Simulation(); % I.e. no simulation to begin with
            obj.preRunModelProcDStr = '';
            obj.stats = SimulatorStats();
            obj.machine = machine; 
            obj.log = log;
            obj.notificationSet = notificationSet;

            % Log it
            obj.log.write(['Creating simulator ' obj.id ' on Machine '...
                           obj.machine.getID() '.']);
        end
        
        % --------------
        function str = getVersion(obj)
            str = obj.version;
        end
        
        % --------------
%         function tf = checkSimCoreCompatibility(testName)
%             tf = any(strcmp(testName, obj.simCoreCompatibilityList));
%         end
        
        % ------------
        function constructRemoteAspect(obj)
            obj.preUploadFiles();           % Simulator aspect defined in a subclass

            % Create the simulator's basedir and commonsdir on the target
            obj.targetBaseDir = fullfile(obj.machine.getBaseDir, obj.id);
            obj.simulationCommonDir = fullfile(obj.targetBaseDir, 'SimulationCommon');
            % The cd probably not necessary
            command = ['cd ' path2UNIX(obj.machine.getBaseDir())...
                       '; mkdir -m ug=rwx '...
                       path2UNIX(obj.targetBaseDir)...
                       '; mkdir  -m ug=rwx '...
                       path2UNIX(obj.simulationCommonDir)...
                       ];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            
            % Copy in the MachineData.dat file from SimulatorCommon
            obj.machine.remoteCopy(obj.machine.getSimulatorCommonFilesPath(),...
                               obj.targetBaseDir, {'MachineData.dat'});
            
            % Transfer in the executable apparatus
            obj.refreshSimulatorFiles()
            
            % Transfer in any model files
            obj.refreshModelFiles();
            
            % now Simulator is ready for operation
            obj.state = SimulatorState.AVAILABLE;
            obj.log.write(['Simulator ' obj.id...
                           ' Version ' obj.getVersion()...
                           ' created on machine '...
                           obj.machine.getID() '.']);
        end
        
        % --------
        function startSimulation(obj, simulation)
        % Set up the simulation and run it - used by NeuroManager class
        % Might want to add return of problems etc (not yet implemented)
            obj.state = SimulatorState.BUSY;
            obj.processedSimulationRUNNINGTransition = false;
            obj.currentSimulation = simulation;
            time = obj.machine.getMachineTime();
            obj.currentSimulation.setHandoffTime(time);
            % Store the ETS in the Simulation for downstream scheduling
            [mPT, ~, mWT, ~, mRT, ~, mFT, ~] = obj.stats.getStats();
            ets = mPT + mWT + mRT + mFT;
            obj.currentSimulation.setETS(ets);
            
            % Notify log+ 
            notificationSubject = ['Re: NeuroManager Notice'];
            msg = ['Starting simulation '...
                   obj.currentSimulation.getID()...
                   ' on simulator ' obj.id ...
                   ' on machine ' obj.machine.getID() '.'];
            obj.log.write(msg);
            if obj.notificationSet.isEnabled()
                if obj.currentSimulation.notify()
                    obj.notificationSet.send(notificationSubject,...
                        msg, '');
                end
            end
            
            obj.refreshSimulatorFiles();

            % ---V
            % Failures here are not detected here; they are detected on the
            % remote and result in a failed simulation.
            
            % This includes the Pre Run Upload Simulation Data Files Stage
            % and the PreRun Processing Host (H) Phase. 
            obj.currentSimulation.prepare(obj.machine, obj);

            % PreRun Model Processing Host (H) Phase
            obj.preRunModelProcPhaseH();

            % PreRun Model Processing PreSubmission (P) Phase
            obj.preRunModelProcPhaseP();

            % Do it
            obj.submitSimulation();
        end

        function refreshSimulatorFiles(obj)
            % Reset simulator for new simulation (help ensure unmodified
            % contents). Clear the simulator basedir and copy from
            % SimulatorCommon. 
            command = ['cd ' path2UNIX(obj.targetBaseDir) ...
                       '; rm ' path2UNIX(fullfile(obj.targetBaseDir, '*')) ...
                       '; cp ' path2UNIX(fullfile(obj.machine.getSimulatorCommonFilesPath(), '*')) ...
                       ' ' path2UNIX(obj.targetBaseDir)];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
        end
        
        % -------------
        % This is part of the Pre Run Upload Simulation Data Files Stage
        % defined in Simulation.m as method UploadInputDataFiles().
        % Override in a subclass to choose specific files; see Sim_SineSim
        % for an example.
        function [sourceFilelist, destFilelist] =...
                defineSimulationInputDataFiles(obj, simulation) %#ok<INUSD>
            sourceFilelist = {};
            destFilelist = {};
        end

        % -------------
        function submitSimulation(obj)
        % Submit the Simulation job and don't wait for a result
            % Simulation state was already set by NeuroManager's checkout.
            % Progress, results, and completion are signaled by files in
            % the simulation's output directory.
            [jobroot, jfn] = obj.preRunJobProc();  
            obj.run(jobroot, jfn);
        end 
        
        % -------------
        % Refer to NeuroManagerStaging.xlsx
        % jfn = job file name
        function [jobRoot, jfn] = preRunJobProc(obj)
            % Get the string that will make PreRun Processing
            % DuringSubmission (D) Phase happen
            obj.preRunModelProcDStr = obj.preRunModelProcPhaseD();

            % Three things to do within this command string: D phase; move
            % to base; run the simulation 
            runCommandString =...
                        [obj.preRunModelProcDStr ...
                         'cd ' path2UNIX(obj.getTargetBaseDir()) ';'...
                         ' printenv; '...
                         './SimRunShell.sh'];

            % Create the job file based on machine job submission type
            jobRoot = obj.currentSimulation.getID();
            jfn = obj.machine.preRunCreateJobFile(obj.machine.getScratchDir(),...
                                            jobRoot,...
                                            obj.getTargetBaseDir(),...
                                            runCommandString);
            % Create the run shell
            obj.preRunCreateRunShell();
        end
        
        % -------------
        % Refer to NeuroManagerStaging.xlsx
        function run(obj, jobRoot, jfn)
            % We run from the simulator base directory; the shell file
            % constructed for each simulation tells where the simulation
            % directories are located. 
            jobID = obj.machine.runNoWait(jobRoot, jfn, obj.getTargetBaseDir());
            obj.currentSimulation.setJobID(jobID);
            % Setting this time here rather than in the simulation's
            % UpdateState() gives better time precision
            time = obj.machine.getMachineTime();
            obj.currentSimulation.setSubmissionTime(time);
        end

        % --------
        function state = updateState(obj)
        % Update the state of the simulator
            % The simulator state reacts to its having a simulation or not
            % and the state of that simulation. In the process it prompts 
            % the simulation to update its own state.  The basic idea is
            % that the simulator runs the simulation.
            if (obj.state == SimulatorState.BUSY)
                simulationState = obj.currentSimulation.updateState();
                
                % Some simulation states result in simulator action
                switch simulationState
                    case SimulationState.RUNNING
                        if ~obj.processedSimulationRUNNINGTransition
                            notificationSubject = ['Re: NeuroManager Notice'];
                            message = ['Simulation ' obj.currentSimulation.getID()...
                                       ' tells us it is running.'];
                            obj.log.write(message);
                            if obj.currentSimulation.notify()
                                if obj.notificationSet.isEnabled()
                                    obj.notificationSet.send(notificationSubject,...
                                                             message, '');
                                end
                            end
                            obj.processedSimulationRUNNINGTransition = true;
                        end
                    case SimulationState.READYFORDOWNLOAD
                        notificationSubject = ['Re: NeuroManager Notice'];
                        message = ['Simulation ' obj.currentSimulation.getID()...
                                   ' tells us it has finished and its results'...
                                   ' are ready for download.'];
                        obj.log.write(message);
                        if obj.currentSimulation.notify()
                            if obj.notificationSet.isEnabled()
                                obj.notificationSet.send(notificationSubject,...
                                                         message, '');
                            end
                        end
                        obj.currentSimulation.initiateDownload();
                    case SimulationState.FULLYPROCESSED
                        obj.endSimulation();
                        obj.setState(SimulatorState.AVAILABLE); 
                    otherwise
                        % Nothing to do
                end
            end
            state = obj.state;
        end
        
        % --------
        function endSimulation(obj)
        % Various things that, from the simulator's POV, need to be done
        % when the simulation has completed. We don't delete a simulation
        % here since the SimSet will use it when doing reports etc.  But we
        % do want to clean up the target and let the log/user know.
            % Remove the target-side file structure
            obj.currentSimulation.postSimulation();

            % Tell log+
            [result, simtime, errMsg, ~] = obj.currentSimulation.getResults(); 

            if strcmp(result, 'FAILED')
                notificationSubject = ['NeuroManager Error'];
                if isempty(errMsg)
                    message = ['Simulation ' obj.currentSimulation.getID()...
                               ' failed with errmsg: ' errMsg '.'];
                else
                    message = ['Simulation ' obj.currentSimulation.getID()...
                               ' failed. Look for error message in '...
                               'the text files in simulation directory '...
                               obj.currentSimulation.getHostBaseDir() ...
                               ' on host.'];
                end
            else   % Later add TIMEOUT and CHECKPOINT results here
                % Only add stats if the simulation is successful
                [handoffTime, submissionTime, runStartTime,...
                 runCompleteTime, simFullProcTime] =...
                                        obj.currentSimulation.getStats();
                % Put the newly gathered simulation stats into the
                % Simulator performance stats
                % THIS IS NOT NECESSARILY THE CORRECT THING TO DO (the -1
                % thing) but having a spurious problem with datetime array
                % minus a double array giving an error
                if (isdatetime(submissionTime) && isdatetime(handoffTime))
                    a = seconds(submissionTime-handoffTime);
                else
                    a = -1;
                end
                if (isdatetime(runStartTime) && isdatetime(submissionTime))
                    b = seconds(runStartTime-submissionTime);
                else
                    b = -1;
                end
                if (isdatetime(runCompleteTime) && isdatetime(runStartTime))
                    c = seconds(runCompleteTime-runStartTime);
                else
                    c = -1;
                end
                if (isdatetime(simFullProcTime) && isdatetime(runCompleteTime))
                    d = seconds(simFullProcTime-runCompleteTime);
                else
                    d = -1;
                end
                obj.stats.addData(a, b, c, d);
                if 0 % just for ease of debug
                    [mPR, sPT, mWT, sWT, mRT, sRT, mFT, sFT] =...
                                                    obj.stats.getStats(); %#ok<UNRCH>
%                     fprintf(['%s:  mPR %f, sPT %f | mWT %f, sWT %f '...
%                              '| mRT %f, sRT %f | mFT %f, sFT %f'],...
%                             obj.getID(), mPR, sPT, mWT, sWT,...
%                             mRT, sRT, mFT, sFT);
%                     fprintf(['%s:  mPR %f | mWT %f | mRT %f | mFT %f |||||'...
%                                  ' sPT %f | sWT %f | sRT %f | sFT %f\n'],...
%                             obj.getID(), mPR, mWT, mRT, mFT, sPT, sWT, sRT, sFT);
%                     fprintf(['%s:  mPR %f | mWT %f '...
%                              '| mRT %f | mFT %f\n'],...
%                             obj.getID(), mPR, mWT, mRT, mFT);
                end
                notificationSubject = ['Re: NeuroManager Notice'];
                message = ['Simulation ' obj.currentSimulation.getID()...
                           ' finished successfully on ' obj.machine.getID() ...
                           '; results downloaded to host. '...
                           'runtime: ' ...
                           datestr(simtime/24/3600, 'HH:MM:SS')];
            end
            obj.log.write(message);
            if obj.currentSimulation.notify()
                if obj.notificationSet.isEnabled()
                    attachFile = fullfile(obj.currentSimulation.getHostBaseDir(),...
                                          [obj.currentSimulation.getID() ...
                                          'AttachMe.pdf']);
                    if 2 == exist(attachFile, 'file')
                        obj.notificationSet.send(notificationSubject,...
                                                 message, attachFile);
                    else
                        obj.notificationSet.send(notificationSubject,...
                                                       message, '');
                    end
                end
            else
                obj.log.write(['Notifications not requested for simulation ' ...
                               obj.currentSimulation.getID() '.']);
            end
        end 

        % --------------
        % Used for cluster-hosted Simulations that are stuck in a long
        % waiting queue and need to be moved to another Simulator
        function tf = pullbackSimulation(obj)
            simulation = obj.currentSimulation;
            if simulation.getState == SimulationState.SUBMITTED
                obj.machine.cancelJob(simulation.getJobID());
                simulation.clearForResubmit();
                tf = true;
            else
                tf = false;
            end
        end
        
        % ------------
        % User must ensure there is no current simulation on the simulator.
        % The RETIRED state means that no simulations will be
        % scheduled on the simulator.
        function retire(obj)
            obj.state = SimulatorState.RETIRED;
        end
        
        % -------------
        function tf = usesClusterManager(obj)
            tf = obj.machine.usesClusterManager();
        end
        
        % -------------
        function postDownloadProcessingSimulatorSpecific(obj, simulation) %#ok<INUSD>
            % Override in subclasses if you need to
        end
        
        % --------------
        % One of the workflow stages (kinda)
        function paramstr = fetchSimulationParamStr(obj)
            paramstr = ['''' strjoin(obj.currentSimulation.params, ''' ''') ''''];
        end
        
        % -------------
        function simulation = getSimulation(obj)
            simulation = obj.currentSimulation;
        end
        
        % -------------
        function list = getBaseSimulatorFileList(obj)
            list = obj.baseSimulatorFileList;
        end
        
        % -------------
        function list = getExtendedSimulatorFileList(obj)
            list = obj.extendedSimulatorFileList;
        end

        % -------------
        function list = getReqdCustomFileList(obj)
            list = obj.reqdCustomFileList;
        end
        
        % -------------
        function list = getAddlCustomFileList(obj)
            list = obj.addlCustomFileList;
        end
        
        % -------------
        function setState(obj, state)
            obj.state = state;
        end
        
        % -------------
        function state = getState(obj)
            state = obj.state;
        end
        
        % -------------
        function id = getID(obj)
            id = obj.id;
        end
        
        % -------------
        function dir = getTargetBaseDir(obj)
            dir = obj.targetBaseDir;
        end
        
        % -------------
        function dir = getSimulationCommonDir(obj)
            dir = obj.simulationCommonDir;
        end
        
        % -------------
        function time = getCurrentTime(obj)
            time = obj.machine.getMachineTime();
        end
        
        % -------------
        function [mPT, sPT, mWT, sWT, mRT, sRT, mFT, sFT] = getStats(obj)
            [mPT, sPT, mWT, sWT, mRT, sRT, mFT, sFT] = obj.stats.getStats();
        end
        
        % -------------
        function resetStats(obj)
            obj.stats.resetStats();
        end
        
        % -------------
        function saveStatsHistory(obj, directory)
            obj.stats.saveStatsHistory(obj.getID(), directory);
        end

        
        % -------------
        % CHANGED THIS FROM DELETE() Aug2016
        % Cleans up the remote machine.
        % We are as explicit as possible for safety; but the ssh package
        % doesn't give us a bash shell, so we have to make do. It would be
        % nice to do this from a list, but there are compile movements and
        % such. By using the full pathnames I hope to be pretty safe.  Using
        % the full pathnames makes the cd's obsolete, I think 
        function removeRemoteAspect(obj)
            % Remove the temp directory from the BaseDir 
            command = ['cd '...
                    path2UNIX(fullfile(obj.targetBaseDir, 'temp'))...
                    '; rm ' path2UNIX(fullfile(obj.targetBaseDir, 'temp', '*'))...
                    '; cd ..; rmdir '...
                    path2UNIX(fullfile(obj.targetBaseDir, 'temp'))];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            
            % Remove the Machine data file from the BaseDir
            command = ['cd ' path2UNIX(obj.targetBaseDir)...
                   '; rm '...
                   path2UNIX(fullfile(obj.targetBaseDir,...
                                                      'MachineData.dat'))];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);

            % Now machine-specific job submission files 
            obj.machine.runJobCleanup(obj.targetBaseDir);
            
            % Remove the common directory 
            command = ['cd '...
                    path2UNIX(obj.getSimulationCommonDir())...
                    '; rm ' path2UNIX(fullfile(obj.getSimulationCommonDir(), '*'))...
                    '; cd ..; rmdir '...
                    path2UNIX(obj.getSimulationCommonDir())];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);

            % Now the simulator directory itself
            command = ['cd '...
                path2UNIX(obj.machine.getBaseDir())...
                '; rmdir '...
                path2UNIX(obj.targetBaseDir)...
                ';'];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
        end
        
        function delete(obj)
            % There may be additional things to do on the host 
            % (not implemented yet)
        end
    end
    
    methods (Access=private)
        preRunCreateRunShell(obj) % See separate file
    end
end
