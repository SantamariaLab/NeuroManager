%{
NeuroManager Simulation Manager for Neuroscience
RELEASE 0.961
September 2015

An application from the Santamaria Laboratory at the 
University of Texas at San Antonio
( http://utsa.edu/Santamarialab/index.htm ).

Grant Acknowledgments:
Funding: NSF-EF 1137897, NSF-DBI 1451032, NIH-G12MD007591 (for use of computational
542 facilities at UTSA), Texas Advanced Computing Center for providing HPC resources.

Software Developer(s): 
David Bruce Stockton
davidbrucestocktonbme@gmail.com

Project PI:
Fidel.Santamaria@utsa.edu

NeuroManager 0.961

UTSA RESEARCH LICENSE (SOURCE CODE)
The University of Texas at San Antonio has developed certain software and
documentation that it desires to make available without charge to anyone for
academic, research, experimental or personal use. This license is designed
to guarantee freedom to use the software for these purposes. If you wish to
distribute or make other use of the software, you may purchase a license to
do so from the University of Texas.
The accompanying source code is made available to you under the terms of
this UT Research License (this "UTRL"). By clicking the "ACCEPT" button,
or by installing or using the code, you are consenting to be bound by
this UTRL. If you do not agree to the terms and conditions of this license,
do not click the "ACCEPT" button, and do not install or use any part
of the code.
The terms and conditions in this UTRL not only apply to the source code
made available by UT, but also to any improvements to, or derivative works
of, that source code made by you and to any object code compiled from such
source code, improvements or derivative works.
1. DEFINITIONS.
1.1 "Commercial Use" shall mean use of Software or Documentation by Licensee
for direct or indirect financial, commercial or strategic gain or advantage,
including without limitation: (a) bundling or integrating the Software with
any hardware product or another software product for transfer, sale or license
to a third party (even if distributing the Software on separate media and not
charging for the Software); (b) providing customers with a link to the
Software or a copy of the Software for use with hardware or another software
product purchased by that customer; or (c) use in connection with the
performance of services for which Licensee is compensated.
1.2 "Derivative Products" means any improvements to, or other derivative
works of, the Software made by Licensee.
1.3 "Documentation" shall mean all manuals, user documentation, and other
related materials pertaining to the Software that are made available to
Licensee in connection with the Software.
1.4 "Licensor" shall mean The University of Texas.
1.5 "Licensee" shall mean the person or entity that has agreed to the
terms hereof and is exercising rights granted hereunder.
1.6 "Software" shall mean the computer program(s) referred to as
"Fractional Integration Toolbox 1.0" made available under this UTRL in
source code form, including any error corrections, bug fixes, patches,
updates or other modifications that Licensor may in its sole discretion
make available to Licensee from time to time, and any object code compiled
from such source code.
2. GRANT OF RIGHTS.
Subject to the terms and conditions hereunder, Licensor hereby grants to
Licensee a worldwide, non- transferable, non-exclusive license to (a) install,
use and reproduce the Software for academic, research,
experimental and personal use (but specifically excluding Commercial Use);
(b) use and modify the Software to create Derivative Products, subject
to Section 3.2; and (c) use the Documentation, if any, solely in connection
with Licensee's authorized use of the Software.
3. RESTRICTIONS; COVENANTS.
3.1 Licensee may not: (a) distribute, sub-license or otherwise transfer copies
or rights to the Software (or any portion thereof) or the Documentation;
(b) use the Software (or any portion thereof) or Documentation for
Commercial Use, or for any other use except as described in Section 2;
(c) copy the Software or Documentation other than for archival and
backup purposes; or (d) remove any product identification, copyright,
proprietary notices or labels from the Software and Documentation.
This UTRL confers no rights upon Licensee except those expressly granted herein.
3.2 Licensee hereby agrees that it will provide a copy of all Derivative
Products to Licensor and that its use of the Derivative Products will be
subject to all of the same terms, conditions, restrictions and limitations
on use imposed on the Software under this UTRL. Licensee hereby grants
Licensor a worldwide, non- exclusive, royalty-free license to reproduce,
prepare derivative works of, publicly display, publicly
perform, sublicense and distribute Derivative Products. Licensee also hereby
grants Licensor a worldwide, non-exclusive, royalty-free patent license to
make, have made, use, offer to sell, sell, import and otherwise transfer the
Derivative Products under those patent claims licensable by Licensee that
are necessarily infringed by the Derivative Products.
4. PROTECTION OF SOFTWARE.
4.1 Confidentiality. The Software and Documentation are the confidential and
proprietary information of Licensor. Licensee agrees to take adequate steps to
protect the Software and Documentation from unauthorized disclosure or use.
Licensee agrees that it will not disclose the Software or Documentation to
any third party.
4.2 Proprietary Notices. Licensee shall maintain and place on any copy of
Software or Documentation that it reproduces for internal use all notices
as are authorized and/or required hereunder. Licensee shall include a copy
of this UTRL and the following notice, on each copy of the Software and
Documentation. Such license and notice shall be embedded in each copy of
the Software, in the video screen display, on the physical medium embodying
the Software copy and on any Documentation:
Copyright Â© 2013, The University of Texas at San Antonio. All rights reserved.
UNIVERSITY EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING THIS SOFTWARE
AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR
ANY PARTICULAR PURPOSE, NON- INFRINGEMENT AND WARRANTIES OF PERFORMANCE, AND
ANY WARRANTY THAT MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF
TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT TO THE USE OF
THE SOFTWARE OR DOCUMENTATION. Under no circumstances shall University be
liable for incidental, special, indirect, direct or consequential damages
or loss of profits, interruption of business, or related expenses which
may arise from use of Software or Documentation, including but not limited
to those resulting from defects in Software and/or Documentation, or loss
or inaccuracy of data of any kind.
5. WARRANTIES.
5.1 Disclaimer of Warranties. TO THE EXTENT PERMITTED BY APPLICABLE LAW,
THE SOFTWARE AND DOCUMENTATION ARE BEING PROVIDED ON AN "AS IS" BASIS WITHOUT
ANY WARRANTIES OF ANY KIND RESPECTING THE SOFTWARE OR DOCUMENTATION, EITHER
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF DESIGN,
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
5.2 Limitation of Liability. UNDER NO CIRCUMSTANCES UNLESS REQUIRED BY
APPLICABLE LAW SHALL LICENSOR BE LIABLE FOR INCIDENTAL, SPECIAL, INDIRECT,
DIRECT OR CONSEQUENTIAL DAMAGES OR LOSS OF PROFITS, INTERRUPTION OF BUSINESS,
OR RELATED EXPENSES WHICH MAY ARISE AS A RESULT OF THIS LICENSE OR OUT OF
THE USE OR ATTEMPT OF USE OF SOFTWARE OR DOCUMENTATION INCLUDING BUT NOT
LIMITED TO THOSE RESULTING FROM DEFECTS IN SOFTWARE AND/OR DOCUMENTATION,
OR LOSS OR INACCURACY OF DATA OF ANY KIND. THE FOREGOING EXCLUSIONS AND
LIMITATIONS WILL APPLY TO ALL CLAIMS AND ACTIONS OF ANY KIND, WHETHER
BASED ON CONTRACT, TORT (INCLUDING, WITHOUT LIMITATION, NEGLIGENCE), OR
ANY OTHER GROUNDS.
6. INDEMNIFICATION.
Licensee shall indemnify, defend and hold harmless Licensor, the
University of Texas System, their Regents, and their officers,
agents and employees from and against any claims, demands, or
causes of action whatsoever caused by, or arising out of, or resulting
from, the exercise or practice of the license granted hereunder by
Licensee, its officers, employees, agents or representatives.
7. TERMINATION.
If Licensee breaches this UTRL, Licensee's right to use the Software
and Documentation will terminate immediately without notice, but all
provisions of this UTRL except Section 2 will survive termination and
continue in effect. Upon termination, Licensee must destroy all copies
of the Software and Documentation.
8. GOVERNING LAW; JURISDICTION AND VENUE.
The validity, interpretation, construction and performance of this UTRL
shall be governed by the laws of the State of Texas. The Texas state
courts of Travis County, Texas (or, if there is exclusive federal
jurisdiction,the United States District Court for the Central
District of Texas) shall have exclusive jurisdiction and venue
over any dispute arising out of this UTRL, and Licensee consents
to the jurisdiction of such courts. Application of the
United Nations Convention on Contracts for the International
Sale of Goods is expressly excluded.
9. EXPORT CONTROLS.
This license is subject to all applicable export restrictions. Licensee
must comply with all export and import laws and restrictions and
regulations of any United States or foreign agency or authority relating
to the Software and its use.
10. U.S. GOVERNMENT END-USERS.
The Software is a "commercial item," as that term is defined in
48 C.F.R. 2.101, consisting of "commercial computer software" and
"commercial computer software documentation," as such terms are
used in 48 C.F.R. 12.212 (Sept. 1995) and 48 C.F.R. 227.7202 (June 1995).
Consistent with 48 C.F.R. 12.212, 48 C.F.R. 27.405(b)(2) (June 1998)
and 48 C.F.R. 227.7202, all U.S. Government End Users acquire the
Software with only those rights as set forth herein.
11. MISCELLANEOUS
If any provision hereof shall be held illegal, invalid or unenforceable,
in whole or in part, such provision shall be modified to the minimum extent
necessary to make it legal, valid and enforceable, and the legality, validity
and enforceability of all other provisions of this UTRL shall not be affected
thereby. Licensee may not assign this UTRL in whole or in part, without
Licensor's prior written consent. Any attempt to assign this UTRL without
such consent will be null and void. This UTRL is the complete and exclusive
statement between Licensee and Licensor relating to the subject matter
hereof and supersedes all prior oral and written and all contemporaneous
oral negotiations, commitments and understandings of the parties, if any.
Any waiver by either party of any default or breach hereunder shall
not constitute a waiver of any provision of this UTRL or of any
subsequent default or breach of the same or a different kind.
END OF LICENSE
%}

% Simulation.m
% A class which defines the Simulation object for the NeuroManager software
% Note: Simulations don't care what machine they run on. They only have a
% simulation type.
classdef Simulation < handle
    properties
        % The ID of this simulation as defined in the SimSpec for this SimSet
        id;
      
        type; % The simulation type from SimType.m
        
        % The full pathname of this simulation's base directory on the host
        % machine. Assigned upon construction.
        hostBaseDir;
        
        targetBaseDir;  % Full pathname of this simulation's base dir on target
        targetInputDir; % Full pathname of this simulation's input dir on target
        targetOutputDir;% Full pathname of this simulation's output dir on target
        targetModelDir; % Full pathname of this simulation's model dir on target
        
        params; % Input parameters - a cell array of strings

        state; % States are defined in class SimulationState
        
        % The job or process ID associated with the running simulation on
        % whatever machine is running it. A positive integer; zero means
        % that the ID is unknown or has not yet been set.
        jobID;
        
        % Turns Notifications on and off for this simulation
        % true = send notifications about this specific simulation; 
        % false = don't send
        notifySwitch;
        
        % The complete pathname of this signal file, 
        % the place of which is in the simulation's host dir.
        signalFileDOWNLOADCOMPLETE;
        signalFileDOWNLOADERROR;

        signalFileSUBMITTED;% Full path of signal file in target output dir
        signalFileRUNNING;  % Full path of RUNNING signal file in target output dir
        signalFileCOMPLETE; % Full path of COMPLETE signal file in target output dir
        signalFileFAILED;   % Full path of FAILED   signal file in target output dir
        
        % Profiling data
        % Remote time this simulation was handed to the simulator
        handoffTime;  
        % Remote time this simulations was submitted to the host resource
        submissionTime; 
        % Remote time this simulation began running on the resource
        runStartTime;
        % Remote time this simulation stopped running on the resource
        runCompleteTime;
        % Remote time this simulation was completely downloaded, etc.
        simFullProcTime;
        % The total time in seconds this simulation is expected to take
        % based on simulator characteristics gathered prior to the time of
        % handoff.   
        ETS; 
        
        % The complete pathname of the results reporting file;
        % does not include major files such as tables, figures, or the like. 
        % First five lines:
        % ID simID        % from the input stream (such as simset)
        % Result RESULT   % FAILED, COMPLETE, etc from SimulationState class
        % Simtime dddddd  % clock time in seconds on target machine
        % Errmsg          % to explain reason for FAILED result or to tell
        %                 % which checkpoint was reached.
        % MLVersion       % the version of MATLAB as reported by the MATLAB
        %                 % 'version' command from the compiled executable
        resultsFile;

        result;         % Holds the end result of the run on target
        executionTime;  % Holds the execution time of the run on target
        errmsg;         % Holds any end error message from run on target
        mlVersion;      % Holds the MATLAB version string 
        
        machine;        % The machine on which this simulation is being run
        simulator;      % The simulator on which this simulation is being run
    end
    
    methods
        % ----------------
        function obj = Simulation(simsetDir, id, type, notify, params)
            if (nargin == 0)
                obj.id = '';
                obj.type = SimType.UNASSIGNED;
                obj.notifySwitch = false;
                obj.params = {}; 
                obj.state = SimulationState.UNASSIGNED;
                obj.jobID = 0;
                obj.hostBaseDir         = '';
                obj.targetBaseDir       = '';
                obj.targetInputDir      = '';
                obj.targetOutputDir     = '';
                obj.targetModelDir     = '';
                obj.signalFileDOWNLOADCOMPLETE = '';
                obj.signalFileDOWNLOADERROR = '';
                obj.signalFileSUBMITTED = '';
                obj.signalFileRUNNING   = '';
                obj.signalFileCOMPLETE  = '';
                obj.signalFileFAILED    = '';
                obj.handoffTime      = datetime(0,0,0,0,0,0);
                obj.submissionTime   = datetime(0,0,0,0,0,0);
                obj.runStartTime     = datetime(0,0,0,0,0,0);
                obj.runCompleteTime  = datetime(0,0,0,0,0,0);
                obj.simFullProcTime  = datetime(0,0,0,0,0,0);
                obj.ETS = 0.0;
                obj.resultsFile         = '';
                obj.result = '';
                obj.executionTime = NaN;
                obj.errmsg = '';
                obj.mlVersion = '';
            else
                % Set the variables
                % (not checking yet for validity)
                obj.id = id;
                obj.type = type;
                obj.notifySwitch = notify;
                obj.params = params; 
                obj.state = SimulationState.UNRUN;
                obj.jobID = 0;

                % Create the hostside simulation directory as a child of
                % the simset directory, but the targetside dirs have to be
                % set externally (by the Simulator class) using this
                % class's SetTargetDirs command
                obj.hostBaseDir = fullfile(simsetDir, obj.id);
                mkdir(obj.hostBaseDir); % PROCESS mkdir FAILURE SOMEDAY SOON
                obj.targetBaseDir = '';
                obj.targetInputDir = '';
                obj.targetOutputDir = '';
                obj.targetModelDir = '';
                obj.signalFileDOWNLOADCOMPLETE =...
                    fullfile(obj.hostBaseDir, 'DOWNLOADCOMPLETE');  % Host side
                obj.signalFileDOWNLOADERROR =...
                    fullfile(obj.hostBaseDir, 'DOWNLOADERROR');
                obj.signalFileSUBMITTED = '';   % Target side; set by SetTargetDirs()
                obj.signalFileRUNNING = '';     % Target side; set by SetTargetDirs()
                obj.signalFileCOMPLETE = '';    % Target side; set by SetTargetDirs()
                obj.signalFileFAILED = '';      % Target side; set by SetTargetDirs()
                obj.submissionTime = datetime(0,0,0,0,0,0);
                obj.runStartTime   = datetime(0,0,0,0,0,0);
                obj.resultsFile = '';
                obj.result = ''; 
                obj.executionTime = NaN;
                obj.errmsg = '';
                obj.mlVersion = '';
            end
        end
        
%         % ---
%         function addToDB(obj, simulatorIndex)
%             if obj.dbH~=0
%                 obj.simulatorIndex = ...
%                     obj.dbH.addSimulationRun(simulatorIndex, obj.getID(), ...
%                                          obj.type, obj.version);
%             else
%                 obj.simulatorIndex = 0;
%             end
%         end
        
        
        % --------------
        function clearForResubmit(obj)
                obj.jobID = 0;
                obj.errmsg = '';
                obj.handoffTime      = datetime(0,0,0,0,0,0);
                obj.submissionTime   = datetime(0,0,0,0,0,0);
                obj.runStartTime     = datetime(0,0,0,0,0,0);
                obj.runCompleteTime  = datetime(0,0,0,0,0,0);
                obj.simFullProcTime  = datetime(0,0,0,0,0,0);
                obj.ETS = 0.0;
                obj.executionTime = NaN;
                obj.resultsFile         = '';
                obj.result = '';
                obj.mlVersion = '';
        end
        
        % --------------
        function prepare(obj, machine, simulator)
        % Does initial setup for the simulation on the target's simulator
            obj.state = SimulationState.INPROGRESS;
            obj.machine = machine;
            obj.simulator = simulator;
            
            % Make directory structure on target for the simulation
            command = ['cd ' path2UNIX(obj.simulator.getTargetBaseDir())];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            simDirName = fullfile(obj.simulator.targetBaseDir, obj.getID());
            inputDirName = fullfile(simDirName, 'input');
            outputDirName = fullfile(simDirName, 'output');
            modelDirName = fullfile(simDirName, 'model');
            command = ['mkdir ' path2UNIX(simDirName)];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            command = ['mkdir ' path2UNIX(inputDirName)];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            command = ['mkdir ' path2UNIX(outputDirName)];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            command = ['mkdir ' path2UNIX(modelDirName)];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            obj.setTargetDirs(simDirName, inputDirName, outputDirName, modelDirName);

            % Pre Run Upload Simulation Data Files Stage (defined just
            % below)
            obj.uploadInputDataFiles();
        end
        
        % ---
%         function transferModelFiles(obj)
%         % Move model files from SimulationCommon to the input directory
%         % Needs redesign (using simulationbase/model) but ok for now.
%             command = ['cp ' path2UNIX(fullfile(obj.simulator.getSimulationCommonDir(), '*')) ...
%                        ' ' path2UNIX(obj.getTargetInputDir())];
%             obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
%         end
        
        % -------------
        % Assumes custom dir source and simulation inputdir as destination
        % This is the Pre Run Upload Simulation Data Files Stage.
        % sourcefilelist is a cell array of strings that are file names only
        % destfilelist is a same-sized cell array of filenames which will
        % be the new names of the source files.  
        % This approach allows the target code to expect a given filename
        % without having to track which one is being accessed.  For
        % example, A01243, B02123, C0315634, and D04 can turn into uploaded
        % InputA, InputB, InputC, and InputD. The SimSet parameter list can
        % specify which files while UserSimulation just always uses InputA,
        % InputB, InputC, InputD. % Override DefineSimulationInputDataFiles
        % in a subclass to actually do a file. See Sim_SineSim.m for an
        % example. The return value is currently unused.
        function result = uploadInputDataFiles(obj)
            [sourceFileList, destFileList] =...
                        obj.simulator.defineSimulationInputDataFiles(obj);
            if ~obj.machine.fileListExist(obj.machine.getCustFileSourceDir(),... 
                                          sourceFileList)
                result = false;
                return;
            end
            % Really should check the return here DO THIS SOON
            obj.machine.fileListToMachineRename(sourceFileList,...
                                    destFileList,...
                                    obj.machine.getCustFileSourceDir(),...
                                    obj.getTargetInputDir())
            result = true;
        end

        % -----------
        function state = updateState(obj)
        % Fetch the simulation's state, but sync host/target first.
            switch obj.state 
                case SimulationState.UNRUN
                    % Nothing to do; a simulation must be started externally
                case SimulationState.INPROGRESS
                    % Nothing to do; a simulation must be submitted externally
                    if obj.machine.checkForCheckfile(obj.getSignalFileSUBMITTED())
                        obj.setState(SimulationState.SUBMITTED);
                    end
                case SimulationState.SUBMITTED
                    % Nothing to do; the target-side simulation must signal
                    % its transition to running
                    if obj.machine.checkForCheckfile(obj.getSignalFileRUNNING())
                        obj.setState(SimulationState.RUNNING);
                        obj.setRunStartTime(datetime('now'));

                        % Grab the data from the RUNNING file
                        command = ['cat '...
                                   path2UNIX(obj.getSignalFileRUNNING())];
                        commandResult = obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
                        jobid = sscanf(commandResult{1}, '%u');
                        if length(commandResult) >= 2
                            timestr = sscanf(commandResult{2}, '%s%c%s');
                            time = datetime(timestr, 'InputFormat', 'dd-MMM-yyyy HH:mm:ss');
                        else
%                             time = '--------------------';
                            time = 0;
                        end
                        
                        obj.setRunStartTime(time);
                        
                        % If the simulation JobID hasn't been set yet, we
                        % grab the target-MATLAB-determined process ID from
                        % within the RUNNING file and stick it in the
                        % simulation for presentation. 
                        if obj.getJobID() == 0
                            obj.setJobID(jobid);
                        end
                    end
                case SimulationState.RUNNING
                    % Nothing to do; the simulation must signal its
                    % completion
                    if obj.machine.checkForCheckfile(obj.getSignalFileCOMPLETE())
                        obj.setState(SimulationState.RUNCOMPLETE);
%                        obj.SetRunCompleteTimeStr(datestr(now));
                        % Grab the data from the COMPLETE file
                        command = ['cat '...
                                   path2UNIX(obj.getSignalFileCOMPLETE())];
                        commandResult = obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
                        %jobid = sscanf(commandResult{1}, '%u');
                        if length(commandResult) >= 1
                            timestr = sscanf(commandResult{1}, '%s%c%s');
                            time = datetime(timestr, 'InputFormat', 'dd-MMM-yyyy HH:mm:ss');
                        else
%                             time = '--------------------';
                            time = 0;
                        end
                        obj.setRunCompleteTime(time);
                        
                    elseif obj.machine.checkForCheckfile(obj.getSignalFileFAILED())
                        obj.setState(SimulationState.RUNCOMPLETE);
                        %obj.SetRunCompleteTimeStr(datestr(now));
                        % Grab the data from the FAILED file
                        command = ['cat '...
                                   path2UNIX(obj.getSignalFileFAILED())];
                        commandResult = obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
                        %jobid = sscanf(commandResult{1}, '%u');
                        if length(commandResult) >= 1
                            timestr = sscanf(commandResult{1}, '%s%c%s');
                            time = datetime(timestr, 'InputFormat', 'dd-MMM-yyyy HH:mm:ss');
                        else
                            time = 0;
                        end
                        obj.setRunCompleteTime(time);
                    end
                case SimulationState.RUNCOMPLETE
                    obj.machine.postRunJobProc(obj); % See NeuroManagerStaging.xlsx
                    % The simulation object must wait for the simulator to
                    % initiate the download.                     
                    obj.setState(SimulationState.READYFORDOWNLOAD);
                case SimulationState.READYFORDOWNLOAD
                    % nothing to do; action is external by simulator
                case SimulationState.DOWNLOADINPROGRESS
                    % The simulation waits in this state for the (parallel)
                    % download to finish
                    % NEED TO PROCESS DOWNLOAD ERROR -- FIX IN FUTURE
                    if (exist(obj.signalFileDOWNLOADCOMPLETE, 'file') == 2)
                        % Post-download simulation-specific processing
                        obj.postDownloadProcessing();
                        obj.setState(SimulationState.FULLYPROCESSED);
                        time = obj.machine.getMachineTime();
                        obj.setSimFullProcTime(time);
                    end
                case SimulationState.FULLYPROCESSED
                    % Nothing to do
                otherwise
                    % ignore RANTOCHECKPOINT for now
            end 
            state = obj.state;
        end
        
        % --------
        function initiateDownload(obj)
        % Used by the simulator to download simulator output files    
            % PreDownload stage 
            obj.preDownload();
            
            % Start the parallel downloading of output files
            % The zipped file in the simulation's output folder comes back
            % to the simulation's host basedir.
            hostDir = obj.getHostBaseDir();
            targetDir = obj.getTargetOutputDir();
            
            obj.setState(SimulationState.DOWNLOADINPROGRESS);

            % DO THIS AND VERIFY SO THAT IF NOT PRESENT CAN DOWNLOAD ALL
            % FILES INSTEAD (not implemented yet)
            targetPath = fullfile(targetDir, [obj.id '.zip']);
            [~, signalFilename,~] = fileparts(obj.signalFileDOWNLOADCOMPLETE);
            [~, errorFilename,~] = fileparts(obj.signalFileDOWNLOADERROR);
            obj.machine.fileFromMachineNoWait(hostDir, targetPath,...
                                        signalFilename, errorFilename);
        end
        
        % --------
        function preDownload(obj)
        % PreDownload stage; See Staging doc.
            command = [' cd ' path2UNIX(obj.getTargetOutputDir())...
                       '; zip ' obj.getID() '.zip *'];
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
        end
        
        
        % --------
        % Suitable for abstracting if required
        function postDownloadProcessing(obj)
        % Refer to NeuroManagerStaging.xlsx
            cd(obj.hostBaseDir);
            zipfile = fullfile(obj.getHostBaseDir(), [obj.id '.zip']);
            % We have already seen the signal file, which supposedly is
            % only produced after the download is done, but there may be 
            % networking slop, so pause a little to let the system settle.
            % (educated guess) 
            delay = 2.0; % seconds HARDWIRED VALUE
            for i=1:10
                if (exist(zipfile, 'file') ~= 2)
                    disp(['Pausing ' num2str(delay)...
                          ' seconds to wait for ' zipfile ' to appear.']);
                    pause(delay);
                else
                    break;
                end
            end
            % This version of NeuroManager does not handle problems with
            % unzipping. In the case of problems, check the host and target
            % and see if there are simulation files that are useful (before
            % rerunning simulations).
            unzip(zipfile, obj.hostBaseDir);
            obj.retrieveResultsFromFile();
            
            % Simulator-specific actions here allow better customization
            obj.simulator.postDownloadProcessingSimulatorSpecific(obj);
        end
        
        % --------
        function  postSimulation(obj)   
            % Note: destroys Data on Target
            % Dismantle the simulation's remote directory structure.
            % Rather than run this all via SSH, we might upload and run a
            % file that will delete all simulation-specific files and
            % dismantle our directory structure for us (this approach not
            % implemented). Could do something with these results
            % (currently not implemented) 
            command = ['cd '...
                path2UNIX(obj.getTargetOutputDir())...
                '; rm '...
                path2UNIX(fullfile(obj.getTargetOutputDir(), '*'))]; 
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            
            command = ['cd '...
                path2UNIX(obj.getTargetModelDir())...
                '; rm '...
                path2UNIX(fullfile(obj.getTargetModelDir(), '*'))]; 
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            
            command = ['cd '...
                path2UNIX(obj.getTargetInputDir())...
                '; rm '...
                path2UNIX(fullfile(obj.getTargetInputDir(), '*'))...
                '; rm -r --preserve-root ' ...
                path2UNIX(fullfile(obj.targetInputDir, 'x86_64'))...
                ]; 
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            
            command = ['cd '...
                path2UNIX(obj.getTargetBaseDir())...
                '; rm '...
                path2UNIX(fullfile(obj.getTargetBaseDir(), '*'))]; 
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
            
            % We be clumsily literal for safety
            command = ['rmdir '...
                path2UNIX(obj.getTargetInputDir())...
                '; rmdir '...
                path2UNIX(obj.getTargetOutputDir())...
                '; rmdir '...
                path2UNIX(obj.getTargetModelDir())...
                '; cd ..;']; 
            command = strcat(command, ['rmdir '...
                path2UNIX(obj.getTargetBaseDir()) ';']);
            obj.machine.issueMachineCommand(command, CommandType.FILESYSTEM);
        end
        
        % ----------------
        % Host and Target Directories - get and set
        function setTargetDirs(obj, base, input, output, model)
        % Sets simulation's base, input, and output dirs as well as signal file paths
            obj.targetBaseDir = base;
            obj.targetInputDir = input;
            obj.targetOutputDir = output;
            obj.targetModelDir = model;
            obj.signalFileSUBMITTED =...
                fullfile(obj.simulator.getTargetBaseDir(), ['stdout' obj.id '.txt']);
            obj.signalFileRUNNING =...
                fullfile(obj.targetOutputDir, 'RUNNING');
            obj.signalFileCOMPLETE =...
                fullfile(obj.targetOutputDir, 'COMPLETE');
            obj.signalFileFAILED =...
                fullfile(obj.targetOutputDir, 'FAILED');
            obj.resultsFile =...
                fullfile(obj.targetOutputDir, 'SimulationResults.txt');
        end
        
        % ----------------
        function dir = getHostBaseDir(obj)
            dir = obj.hostBaseDir;
        end
        
        % ----------------
        function dir = getTargetBaseDir(obj)
            dir = obj.targetBaseDir;
        end
        
        % ----------------
        function dir = getTargetInputDir(obj)
            dir = obj.targetInputDir;
        end
        
        % ----------------
        function dir = getTargetOutputDir(obj)
            dir = obj.targetOutputDir;
        end

        % ----------------
        function dir = getTargetModelDir(obj)
            dir = obj.targetModelDir;
        end

        % ----------------
        function str = getMachineID(obj)
            str = obj.machine.getID();
        end
        
        % ----------------
        function str = getSimulatorID(obj)
            str = obj.simulator.getID();
        end
        
        % ----------------
        function str = getMLVersion(obj)
            str = obj.mlVersion();
        end
        
        % ----------------
        function str = getParam(obj, num)
            str = obj.params{num};
        end
        
        % ----------------
        function state = getState(obj)
            state = obj.state;
        end
        
        % ----------------
        function setJobID(obj, num)
            obj.jobID = num;
        end
        
        % ---------------
        function id = getJobID(obj)
            id = obj.jobID;
        end
        
        % ----------------
        function setHandoffTime(obj, time)
            obj.handoffTime = time;
        end

        % ----------------
        function time = getHandoffTime(obj)
            time = obj.handoffTime;
        end
        
        % ----------------
        function setSubmissionTime(obj, time)
            obj.submissionTime = time;
        end

        % ----------------
        function time = getSubmissionTime(obj)
            time = obj.submissionTime;
        end

        % ----------------
        function setRunStartTime(obj, time)
            obj.runStartTime = time;
        end

        % ----------------
        function time = getRunStartTime(obj)
            time = obj.runStartTime;
        end
        
        % ----------------
        function setRunCompleteTime(obj, time)
            obj.runCompleteTime = time;
        end

        % ----------------
        function time = getRunCompleteTime(obj)
            time = obj.runCompleteTime;
        end
        
        % ----------------
        function setSimFullProcTime(obj, time)
            obj.simFullProcTime = time;
        end

        % ----------------
        function time = getSimFullProcTime(obj)
            time = obj.simFullProcTime;
        end
        
        % ----------------
        % time is a datetime value
        function setETS(obj, ets)
            obj.ETS = ets;
        end
        
        % ----------------
        function time = getETS(obj)
            time = obj.ETS;
        end
        
        % ----------------
        function retrieveResultsFromFile(obj)
        % Pull simulation results from downloaded results file and put into simulation object
            f = fopen(fullfile(obj.hostBaseDir, 'SimulationResults.txt'), 'r');
            % Could use ID to verify, or something; mostly for human eyes
            % when reading the txt file
            idStr = fscanf(f, 'ID %s\n');   %#ok<NASGU>
            resultStr = fscanf(f, 'Result %s\n');
            simTime = fscanf(f, 'Simtime %f\n');
            errMsg = textscan(f, 'Errmsg %s', 'whitespace', '\n');
            mlVersion = textscan(f, 'MATLAB Version %s', 'whitespace', '\n'); %#ok<PROP>
            % Transfer to the object
            obj.result = resultStr;
            obj.executionTime = simTime;
            obj.errmsg = errMsg{1}{1};
            obj.mlVersion = mlVersion{1}{1}; %#ok<PROP>
        end
        
        % --------------
        function [result, simTime, errMsg, mlVersion] = getResults(obj)
        % Get simulation results from the simulation object itself
            result = obj.result;
            simTime = obj.executionTime;
            errMsg = obj.errmsg;
            mlVersion = obj.mlVersion;
        end
        
        % --------------
        function [handoffTime, submissionTime, runStartTime,...
                  runCompleteTime, simFullProcTime] = getStats(obj)
            handoffTime = obj.handoffTime;
            submissionTime = obj.submissionTime;
            runStartTime = obj.runStartTime;
            runCompleteTime = obj.runCompleteTime;
            simFullProcTime = obj.simFullProcTime;
        end
        
        % ----------------
        function id = getID(obj)
        % Returns the ID of this simulation
            id = obj.id;
        end
        
        % ----------------
        function ntfy = notify(obj)
        % Returns T/F as to use notifications for this specific simulation
            ntfy = obj.notifySwitch;
        end
        
        % ----------------
        function type = getType(obj)
            type = obj.type;
        end
        
        % ----------------
        function setExecutionTime(obj, time)
            obj.executionTime = time;
        end
        
        % ----------------
        function time = getExecutionTime(obj)
            time = obj.executionTime;
        end
       
        % ----------------
        function setState(obj, state)
            obj.state = state;
        end
        
        % ----------------
        function path = getSignalFileRUNNING(obj)
        % Returns path of RUNNING signal file
            path = obj.signalFileRUNNING;
        end
        
        % ----------------
        function path = getSignalFileSUBMITTED(obj)
        % Returns path of SUBMITTED signal file
            path = obj.signalFileSUBMITTED;
        end
        
        % ----------------
        function path = getSignalFileCOMPLETE(obj)
        % Returns path of COMPLETE signal file
            path = obj.signalFileCOMPLETE;
        end
        
        % ----------------
        function path = getSignalFileFAILED(obj)
        % Returns path of FAILED signal file
            path = obj.signalFileFAILED;
        end
        
        % ----------------
        function result = getResult(obj)
            result = obj.result;
        end
        
        % ----------------
        function simulator = getSimulator(obj)
            simulator = obj.simulator;
        end
        
        % ----------------
        function machine = getMachine(obj)
            machine = obj.machine;
        end
        
        % No need for a custom destructor; all work done by EndSimulation
        % in the Simulator object.
    end
end
